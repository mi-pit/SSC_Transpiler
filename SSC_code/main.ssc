#/* warn */ include "../../CLibs/src/headers/core/errors.h" /* warn */
#include "../../CLibs/src/headers/util/ctrlflow/unused.h"   /* UNUSED */
#include "../../CLibs/src/structs/dynstr.h"                 /* Dynstr */
#include "../../CLibs/src/util/string_utils.h"              /* str_t */

#include <assert.h>
#include <ctype.h>
#include <stdlib.h> /* alloc */

#define SUPER_STRUCT_NAME_TOKEN "superstruct"
#define LAMBDA_FUNC_START_TOKEN "^\\"

#define LIST_DEFAULT_CAPACITY 256
#define LIST_RESIZE_RATIO     2

struct Normal {
    char hopspop;
};

superstruct Adder
{
    int x;

    int plus( int add )
    {
        return this->x + add;
    }

    void add( int add )
    {
        this->x = this->plus( add );
    }

    int static_add( int a, int b )
    {
        UNUSED( this );
        return a + b;
    }

    void double1( void )
    {
        this->add( this->x );
    }

    void double2( void )
    {
        this->x = this->plus( this->static_add( 0, this->x ) );
    }

    void print( void )
    {
        printf( "%d", this->x );
    }

    static superstruct Adder *new ( int x )
    {
        superstruct Adder *a = calloc( 1, sizeof( superstruct Adder ) );
        assert( a != NULL );
        a->x = x;
        return a;
    }
};


superstruct AdderArray
{
    superstruct Adder *array; // superstruct array
    size_t cap, len;
};

superstruct List
{
    void *items;
    size_t cap, len, el_size;

    static superstruct List *new ( size_t elsize )
    {
        superstruct List *new_ls = calloc( 1, sizeof( superstruct List ) );
        if ( new_ls == NULL )
            return fwarn_ret( NULL, "calloc" );

        new_ls->items = calloc( LIST_DEFAULT_CAPACITY, elsize );
        return new_ls;
    }

    superstruct Adder *get_adder_initialized_to_list_len( void )
    {
        return Adder::new ( this->len );
    }

    void *at_last( void )
    {
        if ( this->len == 0 )
            return NULL;
        return ( char * ) ( this->items ) + ( this->len - 1 ) * ( this->el_size );
    }

    int append( void *data )
    {
        const char *string = "this is a superstruct test file";
        ( void ) string;

        if ( this->len + 1 >= this->cap )
        {
            this->cap *= LIST_RESIZE_RATIO;
            this->items = realloc( this->items, this->cap );
            /* fix this (if it was real code) */
        }

        ++this->len;
        memcpy( this->at_last(), data, this->el_size );
        return RV_SUCCESS;
    }
};

static int static_adder( int a, int b )
{
    return a + b;
}

static void do_nothing( superstruct Adder *a, superstruct Adder *b )
{
    ( void ) a;
    ( void ) b;
}

int main( void )
{
    struct Inner {
        int x;
    } in_1            = { .x = 1 };
    struct Inner in_2 = { .x = 1 };

    ( void ) in_1;
    ( void ) in_2;

    const char *string = "this is a superstruct test file";
    ( void ) string;

    static superstruct List *null_ls = NULL;
    ( void ) null_ls;

    superstruct List *ls = List::new ( sizeof( int ) ); // superstruct
    assert( ls != NULL );                               // after List::new()
    assert( ls->at_last() == NULL );                    // => List__at_last( ls )

    const int x = 12, y = 21;
    superstruct Adder add = { .x = x };

    do_nothing( &add, &add );

    assert( add.plus( y ) == x + y );

    assert( static_adder( 1, 2 ) == 3 );

    assert( add.plus( 123 ) == x + 123 && false ); // abort
}
